const fs = require('fs').promises;
const path = require('path');
const chokidar = require('chokidar');
const wgslink = require('wgslink');

const srcdir = 'src';
const outdir = 'src/gen';
const typesfile = 'src/types';
const ext = '.wgsl';
const vertExt = `.vert${ext}`;
const fragExt = `.frag${ext}`;
const srcGlob = `${srcdir}/**/*${ext}`;
const watchMode = process.argv[2] === '--watch';

// Must match webgpu impl
global.GPUShaderStage = {
	VERTEX: 1,
	FRAGMENT: 2,
	COMPUTE: 4,
};

// Lower binding numbers are given to these so that render passes may only bind them once.
const globalBindings = {
	g_scene: {
		view: {
			binding: 0,
			buffer: {
				type: "uniform"
			},
			visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
		},
		lights: {
			binding: 1,
			buffer: {
				type: "read-only-storage"
			},
			visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
		}
	}
};

// main state
const bundles = {
	// modname: meta
};

function modName(fname) {
	return './' + path.relative(srcdir, fname);
}

function sortBindings([_, a], [__, b]) {
	return +a.binding - +b.binding;
}

async function compileWGSL(fname) {
	if (!isEntry(fname)) return;
	const name = modName(fname);

	try {
		const { text, layout } = wgslink.bundle(fname);
		bundles[name] = { name, text, layout };
	} catch (e) {
		if (watchMode) {
			console.error(e);
			return;
		} else {
			throw e;
		}
	}

	return name;
}

function titleCase(str) {
	return str.split(/[_\.-]/)
		.map(w => w[0].toUpperCase() + w.substring(1).toLowerCase())
		.join('');
}

function symbol(fname) {
	const titled = titleCase(fname);
	return titled[0].toLowerCase() + titled.substring(1);
}

// See GPUBindGroupLayoutEntry
function bindGroupInterface(pass, bg, isVert) {
	if (Object.keys(bg).length === 0) return '';
	// type GPUBindingResource =
	//	|GPUSampler
	//	|GPUTextureView
	//	|GPUBufferBinding
	//	|GPUExternalTexture;
	function resource(layoutEntry) {
		if (isVert || layoutEntry.buffer) return 'GPUBufferBinding';
		if (layoutEntry.sampler) return 'GPUSampler'
		if (layoutEntry.texture) return 'GPUTextureView';

		throw new Error(`unknown resource for layout ${layoutEntry}`);
	}
	return `	export interface ${titleCase(pass)} {
		${Object.entries(bg)
			.map(([k, v]) => `${k}: ${resource(v)};`).join('\n		')}
		[k: string]: ${isVert ? 'GPUBufferBinding' : 'GPUBindingResource'};
	};`;
}

function shaderType(b) {
	const name = b.name;
	if (name.endsWith(vertExt)) return GPUShaderStage.VERTEX;
	if (name.endsWith(fragExt)) return GPUShaderStage.FRAGMENT;

	return GPUShaderStage.COMPUTE;
}

function genTs(b) {
	const bindGroupLayouts = {};

	Object.keys(b.layout)
		.filter(k => k in globalBindings)
		.forEach(k => {
			if (!(k in globalBindings)) throw new Error(`must define bind group ${k} in ${__filename} so shaders which use the group use the correct layout for ALL its bindings`);
			bindGroupLayouts[k] = globalBindings[k];
		});

	Object.keys(b.layout)
		.filter(k => !(k in globalBindings))
		.forEach(k => {
			bindGroupLayouts[k] = Object.entries(b.layout[k])
				.sort(sortBindings)
				.reduce((acc, [k2, v]) => {
					v.binding = +v.binding;
					v.visibility = shaderType(b);
					acc[k2] = v;
					return acc;
				}, {});
		}, {});

	// const vertexArgs = getVertexParams(b);
	// vertexArgs.forEach(v => {
	// 	vertexLayouts[v.name] = {
	// 		stepMode: v.attr.includes('instance') ? 'instance' : 'vertex',
	// 		arrayStride: getSize(v.type, v.name),
	// 		attributes: [
	// 			{
	// 				shaderLocation: location(v.attr.find(a => a.startsWith('location'))),
	// 				format: vertexFormat(v.type, v.name),
	// 				offset: 0,
	// 			}
	// 		]
	// 	};
	// });

	return {
		wgsl: b.text,
		bindGroupLayouts,
	};
}

function outPath(b) {
	return path.join(outdir, b.name + '.ts');
}

async function writeTs(b) {
	const tsPath = outPath(b);
	const paths = {
		ts: tsPath,
		types: path.relative(path.dirname(tsPath), typesfile),
	};

	const { wgsl, bindGroupLayouts } = genTs(b);
	const vertexLayouts = {};

	// const structs = bundle.module.table.visibles
	// 	.filter(b => b !== 'main')
	// 	.map(v => {
	// 		const bundle = wgsl.bindEntryPoint(m, v);
	// 		return wgsl.bundleToAttribute(bundle);
	// 	});

	const basename = path.basename(paths.ts, ext + '.ts');
	const ts = `// Generated by ${__filename}
import { BindGroupLayouts, VertexLayouts } from './${paths.types}.js';

const bindGroupLayouts: BindGroupLayouts = ${JSON.stringify(bindGroupLayouts, null, '\t')};
const vertexLayouts: VertexLayouts = ${JSON.stringify(vertexLayouts, null, '\t')};

export namespace ${titleCase(basename)}Resources {
${Object.entries(bindGroupLayouts)
	.map(([pass, bg]) => bindGroupInterface(pass, bg))
	.concat(bindGroupInterface('Vertex', vertexLayouts, true))
	.join('\n\n')}
}

export const ${symbol(basename)} = {
	code: \`\n${wgsl}\`,
	bindGroupLayouts,
	vertexLayouts,
};
`;
	await fs.mkdir(path.dirname(paths.ts), { recursive: true });
	await fs.writeFile(paths.ts, ts);

	return paths.ts;
}

async function writeIndex() {
	const outpath = path.join(outdir, 'index.ts');
	await fs.mkdir(path.dirname(outpath), { recursive: true });

	const outpaths = Object.values(bundles).filter(Boolean).map(b => outPath(b))
	const index = Array.from(new Set(outpaths))
		.map(outpath => `export * from './${path.relative(outdir, outpath).replace(/.ts$/, '.js')}';`)
		.join('\n');
	await fs.writeFile(outpath, index);
}

function isEntry(fname) {
	return fname.endsWith(vertExt) || fname.endsWith(fragExt);
}

async function compileAndGen(fname) {
	await compileWGSL(fname);
	const affected = Object.keys(bundles);
	for (let i = 0; i < affected.length; i++) {
		const b = bundles[affected[i]];
		const outpath = await writeTs(b);
		if (outpath) console.log(fname, '->', outpath);
	}
}

async function remove(fname) {
	const name = modName(fname);
	delete bundles[name];
}

function onError(fname, e) {
	console.error(`${fname}:`, e);
}

async function walkModules() {
	const watcher = chokidar.watch(srcGlob, { persistent: false });

	const promises = [];
	watcher.on('add', fname => promises.push(compileWGSL(fname)));

	return new Promise(res => watcher.on('ready', () => res(Promise.all(promises))));
}

async function main() {
	await walkModules();

	if (watchMode) {
		const watcher = chokidar.watch(srcGlob, { persistent: true, ignoreInitial: true, });
		watcher.on('add', async fname => {
			if (!isEntry(fname)) return;
			await compileAndGen(fname).catch(e => onError(fname, e));
			await writeIndex();
		});
		watcher.on('change', fname => {
			compileAndGen(fname).catch(e => onError(fname, e));
		});
		watcher.on('unlink', async fname => {
			await remove(fname).catch(e => onError(fname, e));
			await writeIndex();
		});
	}
}

main();
